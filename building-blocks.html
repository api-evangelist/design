---
layout: page
title: 'Building Blocks'
---
<p>These are some of the common building blocks I have pullled from my research into this layer of the API space.</p>
<table width="100%" border="0"><tr>
<td align="left" valign="top" style="padding-left:10px; padding-bottom:5px; background-color: #E0E0E0;">
<h2>Best Practices</h2>
</td>
</tr>
<tr>
<td align="left" valign="top">
<ul>
<li><strong>Use the Web</strong> - The web brings a lot of tools to the table, make sure and learn about existing web technologies, and put them to use across the API design process.</li>
<li><strong>Simplicity</strong> - Consider simplicity at ever turn when designing APIs, providing the small possible unit of value you possibly can--simplicity goes a long way.</li>
<li><strong>Consistency</strong> - Employ consistent approaches to all aspects of API design, providing a familiar approach across all APIs published.</li>
<li><strong>Easy to Read</strong> - While APIs are for computers, they should be easy to read by humans, making documentation more accessible.</li>
<li><strong>Easy to Learn</strong> - Keeping APIs simple, and consistent, will contribute to them being easy to learn about for any potential API consumer.</li>
<li><strong>Hard to Misuse</strong> - When APIs do one thing, and does it well, you reduce the opportunity for misuse, and people putting them to work in unintended ways.</li>
<li><strong>Audience Focused</strong> - APIs should be designed with a specific audience in mind, providing a solution to a problem they are having.</li>
<li><strong>Experience Over Resource</strong> - Make APIs reflect how they will be used, and experienced, over where the API came from and the resource it was derived from.</li>
<li><strong>Use Your Own APIs</strong> - Always use your own APIs, allowing you to understand the challenges with integrating, as well as the pain of operations and outages.</li>
</ul>
</td>
</tr>
<tr>
<td align="left" valign="top" style="padding-left:10px; padding-bottom:5px; background-color: #E0E0E0;">
<h2>Requests</h2>
</td>
</tr>
<tr>
<td align="left" valign="top">
<ul>
<li><strong>SSL</strong> - Transport Layer Security (TLS) and its predecessor, Secure Sockets Layer (SSL), both of which are frequently referred to as 'SSL', are cryptographic protocols designed to provide communications security over a computer network. Always support TLS / SSL by default when it comes to API operations, if at all possible.</li>
<li><strong>Host</strong> - Put sufficient thought into what the baseURL will be for making API calls. Increasingly this element can also be dynamic, like other aspects of API design.</li>
<li><strong>Resource</strong> - Consider how you craft your resources across all API operations. I do not subscribe to specific philosophies around this, just trying to provide a framework to think about this in.</li>
<li><strong>Action</strong> - Allow for standard actions to be taken across resource, but also reflect how APIs will be experienced, providing meaningful action to be taken around any API.</li>
<li><strong>Verbs</strong> - Learn about, and put all HTTP verbs to use when designing APIs.There is more than just GET, and even more than just POST, PUT, and DELETE. </li>
<li><strong>Parameters</strong> - Standardize how parameters are crafted as part of API operations, using intuitive and consistent approaches.</li>
<li><strong>Headers</strong> - Learn about, and use common headers for API requests. Study how the APIs you consumer put headers to work.</li>
<li><strong>Body</strong> - Use the body of each request in a consistent way across API operations. The body provides much more room for more structured data and content.</li>
<li><strong>Versioning</strong> - Establish, and stick to a common versioning strategy, and use throughout API evolutions. Consider putting all versioning information within headers.</li>
<li><strong>Pagination</strong> - Learn about common ways to paginate, and establish a single way to handle across API operations.</li>
<li><strong>Filtering</strong> - Consider how filtering will happen across all APIs, and establish a single way to filter API resources.</li>
<li><strong>Time Selection</strong> - Consider how time selection and series will be handled, and establish a single way for working with time in API operations.</li>
<li><strong>Sorting</strong> - Establish a single approach to how API responses can be sorted, and use across all API resources.</li>
<li><strong>Field Selection</strong> - Consider providing a way that API consumers can select which fields are included in API responses.</li>
<li><strong>Granularity</strong> - Always be aware of the granularity of your API endpoints, and each resource being exposed, keeping everything as small as possible.</li>
<li><strong>Relationship</strong> - Consider how relationships between resources will be handled, and establish a single approach for doing across API operations.</li>
</ul>
</td>
</tr>
<tr>
<td align="left" valign="top" style="padding-left:10px; padding-bottom:5px; background-color: #E0E0E0;">
<h2>Response</h2>
</td>
</tr>
<tr>
<td align="left" valign="top">
<ul>
<li><strong>Status Codes</strong> - Learn about, and use HTTP status codes in a consistent way across all API operations.</li>
<li><strong>Error Handling</strong> - Establish a single error handling strategy, and apply consistently across all API operations.</li>
<li><strong>Rate Limits</strong> - Establish a single approach to rate limiting of API resources, and apply consistently across all API operations.</li>
<li><strong>Caching</strong> - Learn about common approaches to caching, and make sure it is applied through API operations.</li>
<li><strong>eTags</strong> - Learn about etags are used as part of caching and operations, and employ them as part of your caching strategy, and usage of HTTP elements.</li>
<li><strong>Request-Ids</strong> - Employ Request-Ids if possible providing added details for logging, auditing, and reporting on API usage.</li>
<li><strong>UTF-8</strong> - UTF-8 is a character encoding capable of encoding all possible characters, or code points, in Unicode. The encoding is variable-length and uses 8-bit code units. Make sure you use UTF-8 encoding for your API responses, supporting proper encoding.</li>
<li><strong>CORS</strong> - Enable CORS for your API endpoints, providing the most flexibility possible in making API calls.</li>
<li><strong>JSONP</strong> - Provide JSONP if you are unable to enable CORS, allowing for easier integrations.</li>
</ul>
</td>
</tr>
<tr>
<td align="left" valign="top" style="padding-left:10px; padding-bottom:5px; background-color: #E0E0E0;">
<h2>Media Types</h2>
</td>
</tr>
<tr>
<td align="left" valign="top">
<ul>
<li><strong>application/json</strong> - Provide JSON media types for API responses.</li>
<li><strong>application/xml</strong> - Provide XML media types for API responses.</li>
<li><strong>application/csv</strong> - Provide CSV media types for API responses.</li>
<li><strong>text/html</strong> - Provide HTML media types for API responses.</li>
<li><strong>application/atom+xml</strong> - Provide ATOM media types for API responses.</li>
</ul>
</td>
</tr>
<tr>
<td align="left" valign="top" style="padding-left:10px; padding-bottom:5px; background-color: #E0E0E0;">
<h2>Open Standards</h2>
</td>
</tr>
<tr>
<td align="left" valign="top">
<ul>
<li><strong>JSON Schema</strong> - JSON Schema, describes your JSON data format. JSON Hyper-Schema, turns your JSON data into hyper-text. Use JSON schema when possible to standardize and validate your JSON structure.</li>
<li><strong>iCalendar</strong> - Use iCalendar when representing date / time formats in your API responses.</li>
<li><strong>vCard</strong> - vCard is a file format standard for electronic business cards. vCards are often attached to e-mail messages, but can be exchanged in other ways, such as on the World Wide Web or instant messaging. They can contain name and address information, telephone numbers, e-mail addresses, URLs, logos, photographs, and audio clips. Use vCard when representing contact data in your API responses.</li>
<li><strong>KML</strong> - When working with mapping data, represent it using KML when possible.</li>
<li><strong>geoRSS</strong> - Also consider geoRSS when representing you geographic data.</li>
<li><strong>m3u</strong> - When providing formatted data for media formats, consider using m3u.</li>
<li><strong>UUID</strong> - Use a universally unique identifier (UUID) when possible. </li>
<li><strong>ISO 8601 (Date / Time)</strong> - ISO 8601 Data elements and interchange formats – Information interchange – Representation of dates and times is an international standard covering the exchange of date and time-related data. The purpose of this standard is to provide an unambiguous and well-defined method of representing dates and times, so as to avoid misinterpretation of numeric representations of dates and times, particularly when data are transferred between countries with different conventions for writing numeric dates and times.</li>
<li><strong>ISO 4217 (Currency)</strong> - Use ISO 427 data elements and interchange formats for the representation currency codes. ISO 4217 is a standard published by International Organization for Standardization, which delineates currency designators, country codes (alpha and numeric), and references to minor units in three tables: current currency & funds code list, current funds codes, list of codes for historic denominations of currencies & funds.</li>
<li><strong>ISO 3166 (Country)</strong> - Use ISO 3166 data elements and interchange formats for the representation country codes. The purpose of ISO 3166 is to define internationally recognized codes of letters and/or numbers that we can use when we refer to countries and subdivisions. However, it does not define the names of countries .</li>
<li><strong>RDFa</strong> - Consider using RDFa for adding rich meta data to HTML representations.</li>
<li><strong>Schema.org</strong> - Consider using Schema.org representations for common data elements.</li>
</ul>
</td>
</tr>
<tr>
<td align="left" valign="top" style="padding-left:10px; padding-bottom:5px; background-color: #E0E0E0;">
<h2>Design Process</h2>
</td>
</tr>
<tr>
<td align="left" valign="top">
<ul>
<li><strong>Definitions</strong> - Usage of common API definition formats like Swagger, API Blueprint, RAML, and others for describing and defining APIs.</li>
<li><strong>Editor</strong> - An IDE for editing API definitions, as well as possible GUI interface for editing all of API details through desktop or web tooling.</li>
<li><strong>Forkable</strong> - Allow an API definition to be forked, and built upon using a common API definition format.</li>
<li><strong>Sharing</strong> - Allow for API definitions to be shared amongst team members through links, chat, email, and other channels.</li>
<li><strong>Collaboration</strong> - Enable the collaboration between users, both technical, as well as business stakeholders.</li>
<li><strong>Annotation</strong> - Provide tooling for annotating API definitions that the design it represents, leaving notes and comments at all layers.</li>
<li><strong>Translation</strong> - Allowing for the translation of API designs between common API definition formats, allowing users to speak in any format.</li>
<li><strong>Highlighting</strong> - Enable highlighting of specific aspects of an API design to differentiate it from other areas, and establishing common patterns.</li>
</ul>
</td>
</tr>
<tr>
<td align="left" valign="top" style="padding-left:10px; padding-bottom:5px; background-color: #E0E0E0;">
<h2>Organization</h2>
</td>
</tr>
<tr>
<td align="left" valign="top">
<ul>
<li><strong>Guide</strong> - Pull together a common API design guide for use across an organization and sharing with the public to demonstrate a standard approach is being used.</li>
<li><strong>Notebook</strong> - A notebook for storing of API definitions into a single, potentially shareable location that can be used by an individual or group throughout the API lifecycle.</li>
<li><strong>Collections</strong> - A folder or collection of API definitions mean to represent a single or multiple API descriptions and definitions, for use throughout API lifecycle.</li>
<li><strong>Dictionary</strong> - A common set of API values to help provide consistent naming and patterns to be used at different layers of the API design process.</li>
<li><strong>Contact</strong> - A common approach to defining and providing relevant contact information for each API resource crafted.</li>
</ul>
</td>
</tr>
<tr>
<td align="left" valign="top" style="padding-left:10px; padding-bottom:5px; background-color: #E0E0E0;">
<h2>Internationalization</h2>
</td>
</tr>
<tr>
<td align="left" valign="top">
<ul>
<li><strong>Accept-Language</strong> - Set the language the API should be speaking using&nbsp;Accept-Language.d</li>
</ul>
</td>
</tr>
<tr>
<td align="left" valign="top" style="padding-left:10px; padding-bottom:5px; background-color: #E0E0E0;">
<h2>Other</h2>
</td>
</tr>
<tr>
<td align="left" valign="top">
<ul>
<li><strong>Parser</strong> - An API definition parser, available in multiple languages and open up the programmatic generation of API definitions as localized object.</li>
<li><strong>Interactive Documentation / Console</strong> - Generated API documentation allowing developers to make calls against APIs as they are learning about the interface, turning API education into a hands on experience.</li>
<li><strong>Validator</strong> - Tools for validating API calls, enabling developers to determine which types of calls will be valid, using central API definition and schema.</li>
<li><strong>Github Sync</strong> - The ability to store and sync API definitions with Github, providing a central public or private repository for the definition of an API resource.</li>
<li><strong>Command Line</strong> - Command line tooling for use as part of the API design process, allowing developers to use single commands at the prompt.</li>
<li><strong>Translator</strong> -  Tools for translating between various API definitions, allowing the transformation from RAML to Swagger, and between each API definition format.</li>
</ul>
</td>
</tr>
</table>